<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="./">
    <title>Chapter 9 — 可观测性：Trace/Span、日志、指标与可复现</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/highlight.css">
    <script src="assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebar-search-input" placeholder="搜索..." autocomplete="off">
            </div>
            <div id="tree-container">
                <nav class="tree-nav" role="tree">
                    <div class="tree-item " >
                        <a href="index.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">《用 IO Monad 搭建 LLM Agent：从 Kleisli 到事件建模与 FRP》目录（index.md）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter1.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 1 — LLM Agent 的“抽象边界”：为什么从 IO Monad 出发</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter2.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 2 — IO Monad 速成：从概念到工程实现</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter3.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 3 — Kleisli Arrow：把“带 IO 的函数”当作可组合箭头</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter4.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 4 — Agent DSL：把工具、记忆与控制流做成“可解释的 effect”</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter5.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 5 — Runtime 与调度：从解释器到并发、取消与资源管理 (chapter5.md)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter6.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 6 — 事件建模：IO timeout、重试、退避、熔断与预算</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter7.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 7 — Coding Agent 的 Loop Detection：让 Agent 可终止、可解释</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter8.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 8 — A/B Test 与评估：把实验嵌进 IO/Kleisli 管道</span>
                        </a>
                    </div>
                
                    <div class="tree-item active" >
                        <a href="chapter9.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 9 — 可观测性：Trace/Span、日志、指标与可复现</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter10.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 10 — 与 FRP 的关系：当 Agent 变成“事件流处理器” (chapter10.md)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter11.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 11 — 综合案例：实现一个可插拔的 Coding Agent (chapter11.md)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter12.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 12 — 扩展阅读与路线图：通往类型安全与生产环境的彼岸</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="CLAUDE.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                </nav>
            </div>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="chapter-9-tracespan">Chapter 9 — 可观测性：Trace/Span、日志、指标与可复现</h1>
<h2 id="1">1. 开篇段落：打破“随机性”的诅咒</h2>
<p>在传统软件工程中，如果一个函数输入 <code>x</code> 输出 <code>y</code>，它永远都输出 <code>y</code>。但在 LLM Agent 开发中，我们面临着<strong>双重不确定性</strong>：</p>
<ol>
<li><strong>模型的不确定性</strong>：同样的 Prompt，LLM 可能会给出不同的推理路径。</li>
<li><strong>环境的不确定性</strong>：工具调用的结果（如搜索结果、数据库状态）随时间变化。</li>
</ol>
<p>当 Agent 在生产环境中“发疯”时（例如陷入死循环、输出乱码、乱调用工具），开发者往往束手无策。传统的 <code>print</code> 调试法在异步、并发、多步骤的 Agent 面前毫无招架之力。</p>
<p><strong>本章的核心观点</strong>：可观测性（Observability）不是系统写完后“外挂”上去的功能，而是<strong>Effect 的一部分</strong>。通过 IO Monad 和 Kleisli Arrow，我们可以：</p>
<ul>
<li>把 <strong>Tracing</strong> 做成一个包裹在所有计算外层的“洋葱皮”。</li>
<li>把 <strong>Logging</strong> 做成结构化的事件流。</li>
<li>把 <strong>Randomness</strong> 和 <strong>IO</strong> 做成可替换的代数结构，从而实现<strong>100% 的确定性回放（Deterministic Replay）</strong>。</li>
</ul>
<hr />
<h2 id="2">2. 深度论述</h2>
<h3 id="21-agent">2.1 可观测性的三支柱（在 Agent 语境下）</h3>
<p>| 支柱 | 传统后端定义 | <strong>LLM Agent 特有定义</strong> | 关键数据示例 |</p>
<table>
<thead>
<tr>
<th>支柱</th>
<th>传统后端定义</th>
<th><strong>LLM Agent 特有定义</strong></th>
<th>关键数据示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Logs</strong></td>
<td>离散的系统事件</td>
<td><strong>思维快照</strong>：记录 Agent 的每一次“内心独白”和决策瞬间。</td>
<td>User Input, Prompt, Raw LLM Output, Parsed Thought</td>
</tr>
<tr>
<td><strong>Traces</strong></td>
<td>请求的调用链路</td>
<td><strong>推理因果链</strong>：将 Prompt 组装、LLM 请求、工具执行串联起来，展示耗时与依赖。</td>
<td>Latency, Parent-Span-ID, Token Usage per Step</td>
</tr>
<tr>
<td><strong>Metrics</strong></td>
<td>聚合的值指标</td>
<td><strong>健康度与成本</strong>：监控 Token 消耗速率、工具错误率、意图识别准确率。</td>
<td>Cost($), Tool_Error_Rate, Tokens/sec</td>
</tr>
</tbody>
</table>
<h3 id="22-kleisli-arrow">2.2 Kleisli Arrow 与隐式上下文传播</h3>
<p>在构建 Agent Pipeline 时，我们通常将多个步骤组合：
<code>Plan &gt;=&gt; Execute &gt;=&gt; Summarize</code></p>
<p>如果手动传递 <code>TraceId</code>，函数签名会变得非常丑陋：
<code>Plan: (Input, TraceId) -&gt; IO (Plan, TraceId)</code></p>
<p><strong>Kleisli 的魔法</strong>在于，我们可以将 <code>TraceId</code> 隐藏在 Monad <code>m</code> 中。如果 <code>m</code> 是 <code>ReaderT TraceContext IO</code>，那么所有的步骤<strong>自动</strong>拥有读取和携带上下文的能力，而无需修改函数签名。</p>
<h4 id="221-withspan">2.2.1 <code>withSpan</code> 的高阶抽象</h4>
<p>我们定义一个组合子（Combinator） <code>withSpan</code>，它接受一个名字和一个 Kleisli Arrow，并返回一个新的 Kleisli Arrow。</p>
<div class="codehilite"><pre><span></span><code><span class="c1">-- 伪代码类型签名</span>
<span class="nf">withSpan</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
</code></pre></div>

<p><strong>它的内部逻辑是：</strong></p>
<ol>
<li>从上下文中获取当前的 <code>parent_span_id</code>。</li>
<li>生成一个新的 <code>span_id</code>。</li>
<li>记录 <code>SpanStart</code> 事件（包含时间戳）。</li>
<li>执行原本的计算 <code>(a -&gt; m b)</code>，并将新的 <code>span_id</code> 设为下游的 parent。</li>
<li>计算结束后（无论成功失败），记录 <code>SpanEnd</code> 事件。</li>
</ol>
<h4 id="ascii-kleisli-trace">ASCII 图解：基于 Kleisli 的 Trace 树</h4>
<div class="codehilite"><pre><span></span><code>[Root Span: Process User Request] ID: 100
  |
  +--- [Span: Retrieve Memory] ID: 101, Parent: 100
  |      |
  |      +--- (Event: Vector DB Query embedding=[0.1, ...])
  |
  +--- [Span: LLM Reason] ID: 102, Parent: 100
  |      |
  |      +--- (Attribute: model=&quot;gpt-4&quot;)
  |      +--- (Attribute: temperature=0.7)
  |      +--- (Event: Token Stream Start)
  |      +--- (Event: Token Stream End)
  |
  +--- [Span: Tool Execution &quot;calc&quot;] ID: 103, Parent: 100
         |
         +--- (Attribute: args=&quot;1+1&quot;)
         +--- (Error: Timeout) &lt;--- 自动捕获异常
</code></pre></div>

<h3 id="23-canonical-log-lines">2.3 结构化日志：Canonical Log Lines</h3>
<p>不要打印 "Start processing..." 这种废话。在 Agent 系统中，每一行日志都应该是一个<strong>结构化对象（JSON）</strong>。</p>
<p><strong>关键设计原则</strong>：</p>
<ol>
<li><strong>关联性</strong>：所有日志必须包含 <code>trace_id</code> 和 <code>span_id</code>。</li>
<li>
<p><strong>分层</strong>：
* <strong>Level 1 (Business)</strong>: <code>UserQuery</code>, <code>FinalAnswer</code>
* <strong>Level 2 (Reasoning)</strong>: <code>Thought</code>, <code>Plan</code>, <code>ToolSelection</code>
* <strong>Level 3 (Debug)</strong>: <code>RawPrompt</code>, <code>FullLLMResponse</code>, <code>HttpPayload</code></p>
</li>
<li>
<p><strong>脱敏</strong>：在写入底层 IO 之前，必须经过一个 Redactor（脱敏器）。</p>
</li>
</ol>
<h3 id="24-reproducibilityvcr">2.4 圣杯：可复现性（Reproducibility）与“VCR 模式”</h3>
<p>这是本章的重头戏。Agent 难以调试是因为它不仅有逻辑，还有<strong>副作用（Side Effects）</strong>。IO Monad 允许我们将副作用<strong>解耦</strong>为描述（Description）和解释（Interpretation）。</p>
<h4 id="241-entropy">2.4.1 控制熵源 (Entropy)</h4>
<p>LLM 的 <code>temperature</code> 依赖随机数生成器。如果我们在 Effect 系统中抽象了 <code>Rand</code>：</p>
<div class="codehilite"><pre><span></span><code><span class="kd">interface</span><span class="w"> </span><span class="nx">Rand</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">nextFloat</span><span class="p">()</span><span class="o">:</span><span class="w"> </span><span class="nx">IO</span><span class="o">&lt;</span><span class="kt">number</span><span class="o">&gt;</span><span class="p">;</span>
<span class="w">  </span><span class="nx">nextInt</span><span class="p">(</span><span class="nx">max</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="nx">IO</span><span class="o">&lt;</span><span class="kt">number</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<ul>
<li><strong>生产模式</strong>：使用 <code>System.Random</code>。</li>
<li><strong>回放模式</strong>：使用 <code>PseudoRandom(seed)</code>。只要 Seed 固定，且程序逻辑未变，随机数序列就固定，LLM 在相同参数下的行为（理论上）更可控，或者至少我们可以控制像“重试抖动时间”、“负载均衡路由”这些非 LLM 的随机性。</li>
</ul>
<h4 id="242-record-replay">2.4.2 录制与回放 (Record &amp; Replay)</h4>
<p>我们实现两个特殊的 Interpreter：</p>
<ol>
<li>
<p><strong>Recorder (录制器)</strong>：
* 作为“中间人”代理。
* 当 Agent 请求 <code>Http.get("google.com")</code> 时，Recorder 执行真实请求。
* 将 <code>{"req": "google.com", "res": "...", "timestamp": 12345}</code> 写入磁盘上的 <code>tape.json</code> 文件。</p>
</li>
<li>
<p><strong>Replayer (回放器)</strong>：
* <strong>断网运行</strong>。
* 当 Agent 请求 <code>Http.get("google.com")</code> 时，Replayer 拦截请求。
* 它计算请求的<strong>指纹 (Hash)</strong>，在 <code>tape.json</code> 中查找匹配项。
* 如果找到，直接返回录制的结果（哪怕那是上周的数据）。
* 如果没找到，报错 <code>NonDeterminismError</code>：说明你的代码逻辑变了，发起了新的请求。</p>
</li>
</ol>
<p><strong>这一机制价值</strong>：</p>
<ul>
<li><strong>CI/CD 集成</strong>：你可以把一次复杂的 Agent 失败案例录制下来，放入单元测试库。以后每次代码提交，都会瞬间跑完这个测试，<strong>无需消耗 Token，也无需联网</strong>。</li>
<li><strong>调试</strong>：可以在本地单步调试线上发生的错误，复现那一刻的所有变量状态。</li>
</ul>
<hr />
<h2 id="3">3. 本章小结</h2>
<ul>
<li><strong>Trace 是骨架</strong>：利用 Kleisli Arrow 的组合性，使用 <code>withSpan</code> 自动管理 Trace Context，避免手动传参的“代码污染”。</li>
<li><strong>结构化是血肉</strong>：日志必须是机器可读的 JSON，包含 <code>trace_id</code> 以便在可视化工具（如 Jaeger/Grafana）中串联。</li>
<li><strong>IO 是边界</strong>：通过将所有外部交互（网络、时间、随机数）抽象为 Effect，我们获得了“上帝视角”。</li>
<li><strong>回放是时间机器</strong>：通过 Interpreter 替换，我们可以将不可预测的 Agent 运行转化为确定性的测试用例。</li>
</ul>
<hr />
<h2 id="4">4. 练习题</h2>
<h3 id="50">基础题 (50%)</h3>
<p><strong>练习 9.1：Trace Context 的设计</strong>
设计一个不可变的数据结构 <code>TraceContext</code>。它需要包含哪些字段才能支持 OpenTelemetry 标准？</p>
<blockquote>
<p><strong>Hint</strong>: 至少需要 Trace ID, Span ID, Trace Flags (sampled?), Baggage (跨服务传递的 KV)。</p>
</blockquote>
<details>
<summary>参考答案</summary>
<div class="codehilite"><pre><span></span><code><span class="c1">// TypeScript 示例</span>
<span class="kd">interface</span><span class="w"> </span><span class="nx">TraceContext</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// 整个调用链的唯一标识 (128-bit hex)</span>
<span class="w">  </span><span class="nx">traceId</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// 当前步骤的唯一标识 (64-bit hex)</span>
<span class="w">  </span><span class="nx">spanId</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// 父步骤的标识 (根节点为 null)</span>
<span class="w">  </span><span class="nx">parentSpanId?</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// 采样标志 (00=不采样, 01=采样)</span>
<span class="w">  </span><span class="nx">traceFlags</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// Baggage: 随上下文传播的键值对，如 userId, environment</span>
<span class="w">  </span><span class="nx">baggage</span><span class="o">:</span><span class="w"> </span><span class="kt">Record</span><span class="o">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="kt">string</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

</details>
<p><strong>练习 9.2：日志等级分类</strong>
以下信息分别属于什么日志等级（DEBUG, INFO, WARN, ERROR）？</p>
<ol>
<li>LLM 返回 429 Too Many Requests。</li>
<li>Agent 决定使用 Calculator 工具。</li>
<li>原始的 JSON Prompt 字符串（20KB）。</li>
<li>工具调用返回了非法的 UTF-8 字符，Agent 自动重试。</li>
</ol>
<details>
<summary>参考答案</summary>
<ol>
<li><strong>WARN</strong> (如果是偶尔发生且能重试) 或 <strong>ERROR</strong> (如果重试耗尽)。</li>
<li><strong>INFO</strong> (这是业务流程的关键节点)。</li>
<li><strong>DEBUG</strong> (数据量大，仅调试用)。</li>
<li><strong>WARN</strong> (系统出现了异常但自动恢复了)。</li>
</ol>
</details>
<p><strong>练习 9.3：Span 的颗粒度</strong>
在 <code>Agent -&gt; LLM -&gt; Agent</code> 的循环中，Tokenizer 的编码（Encode）和解码（Decode）操作通常非常快（微秒级）。你应该为每一次 Encode/Decode 都创建一个 Span 吗？为什么？</p>
<blockquote>
<p><strong>Hint</strong>: 考虑 Trace 存储成本和可视化时的信噪比。</p>
</blockquote>
<details>
<summary>参考答案</summary>
<p><strong>不应该</strong>。</p>
<ol>
<li><strong>性能开销</strong>：创建 Span 本身有开销，如果操作比 Span 创建还快，得不偿失。</li>
<li><strong>信噪比</strong>：在 Trace 视图中，成千上万个微小的 Encode Span 会淹没真正的 IO 调用（如网络请求）。</li>
<li><strong>建议</strong>：可以将整个 "Token Processing" 聚合为一个 Span，或者只在 Metric 中记录耗时。</li>
</ol>
</details>
<h3 id="50_1">挑战题 (50%)</h3>
<p><strong>练习 9.4：实现简单的 Replayer 匹配逻辑</strong>
编写一个伪代码函数 <code>findMatch(tape, request)</code>。<code>tape</code> 是录制的列表，<code>request</code> 是当前的请求。
挑战：如果 Agent 并发发起了两个相同的请求（例如都查了 "weather: Beijing"），你的匹配逻辑如何保证顺序正确？</p>
<blockquote>
<p><strong>Hint</strong>: Tape 可以是有序队列，或者是基于 (Hash + Counter) 的 Map。</p>
</blockquote>
<details>
<summary>参考答案</summary>
<div class="codehilite"><pre><span></span><code><span class="kr">type</span><span class="w"> </span><span class="nx">Interaction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nx">req</span><span class="o">:</span><span class="w"> </span><span class="kt">any</span><span class="p">;</span><span class="w"> </span><span class="nx">res</span><span class="o">:</span><span class="w"> </span><span class="kt">any</span><span class="p">;</span><span class="w"> </span><span class="nx">id</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="w"> </span><span class="p">};</span>

<span class="kd">class</span><span class="w"> </span><span class="nx">Replayer</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// 必须用 Iterator 或 Cursor 保持状态，因为顺序很重要</span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="nx">tapeIterator</span><span class="o">:</span><span class="w"> </span><span class="kt">Iterator</span><span class="o">&lt;</span><span class="nx">Interaction</span><span class="o">&gt;</span><span class="p">;</span>

<span class="w">  </span><span class="nx">replay</span><span class="p">(</span><span class="nx">currentReq</span><span class="o">:</span><span class="w"> </span><span class="kt">any</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="nx">any</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">nextRec</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">tapeIterator</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nx">nextRec</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">throw</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="s2">&quot;Tape exhausted! Code executed more steps than recorded.&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">recorded</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">nextRec</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// 关键：校验请求是否匹配</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="nx">deepEqual</span><span class="p">(</span><span class="nx">recorded</span><span class="p">.</span><span class="nx">req</span><span class="p">,</span><span class="w"> </span><span class="nx">currentReq</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">throw</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="ne">Error</span><span class="p">(</span><span class="sb">`</span>
<span class="sb">        Non-deterministic behavior detected!</span>
<span class="sb">        Expected: </span><span class="si">${</span><span class="nb">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">recorded</span><span class="p">.</span><span class="nx">req</span><span class="p">)</span><span class="si">}</span>
<span class="sb">        Actual:   </span><span class="si">${</span><span class="nb">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">currentReq</span><span class="p">)</span><span class="si">}</span>
<span class="sb">      `</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">recorded</span><span class="p">.</span><span class="nx">res</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p><em>对于并发场景，简单的线性 Iterator 不够。通常需要计算 <code>hash(req)</code>，然后维护一个 map: <code>Map&lt;RequestHash, Queue&lt;Response&gt;&gt;</code>。每次取出队列头部的响应。</em></p>
</details>
<p><strong>练习 9.5：分布式 Tracing 的传播</strong>
假设你的 Agent 需要调用一个外部的 Python 服务（Web Search Service）。你需要通过 HTTP Headers 传递 Trace Context。
请写出在 HTTP Client Effect 中，如何注入 <code>traceparent</code> header。</p>
<blockquote>
<p><strong>Hint</strong>: W3C Trace Context 标准格式。</p>
</blockquote>
<details>
<summary>参考答案</summary>
<div class="codehilite"><pre><span></span><code><span class="c1">// 在 Http Effect 的实现中</span>
<span class="kd">function</span><span class="w"> </span><span class="nx">callExternalService</span><span class="p">(</span><span class="nx">url</span><span class="o">:</span><span class="w"> </span><span class="kt">string</span><span class="p">,</span><span class="w"> </span><span class="nx">ctx</span><span class="o">:</span><span class="w"> </span><span class="kt">TraceContext</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// W3C Trace Context 格式: version-traceId-spanId-flags</span>
<span class="w">  </span><span class="kd">const</span><span class="w"> </span><span class="nx">traceParent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sb">`00-</span><span class="si">${</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">traceId</span><span class="si">}</span><span class="sb">-</span><span class="si">${</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">spanId</span><span class="si">}</span><span class="sb">-01`</span><span class="p">;</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nx">fetch</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">headers</span><span class="o">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="s2">&quot;traceparent&quot;</span><span class="o">:</span><span class="w"> </span><span class="nx">traceParent</span><span class="p">,</span>
<span class="w">      </span><span class="c1">// 可选: 传递 baggage</span>
<span class="w">      </span><span class="s2">&quot;tracestate&quot;</span><span class="o">:</span><span class="w"> </span><span class="nx">serializeBaggage</span><span class="p">(</span><span class="nx">ctx</span><span class="p">.</span><span class="nx">baggage</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">});</span>
<span class="p">}</span>
</code></pre></div>

</details>
<p><strong>练习 9.6：高阶思维——"观测者效应"</strong>
在强类型语言中，为了收集 Metrics（例如统计所有工具调用的成功率），你引入了一个 <code>MetricWriter</code> Effect。
但是，如果在高并发下，<code>MetricWriter</code> 的锁或 I/O 变慢了，会不会拖慢 Agent 的主流程？
如何利用各种手段（如 IO Monad 的异步特性、采样、批处理）来最小化观测者效应？</p>
<details>
<summary>参考答案</summary>
<ol>
<li><strong>Fire-and-Forget (异步)</strong>：在 <code>IO</code> 链中，使用 <code>fork</code> 或 <code>spawn</code> 将 Metric 写入操作放入后台线程/纤程，主流程不等待其完成。</li>
<li><strong>Buffer &amp; Batch (缓冲与批处理)</strong>：不要每产生一个指标就发一次网络请求。在内存中积累（Buffer），每 10 秒或满 100 条批量发送。</li>
<li><strong>Sampling (采样)</strong>：对于高频 Trace（如 Token 流），只记录 1% 的请求。</li>
<li><strong>Local Aggregation (本地聚合)</strong>：对于 Counter 类指标，在本地原子变量累加，定时上报快照，而不是每次都发 Event。</li>
</ol>
</details>
<hr />
<h2 id="5-gotchas">5. 常见陷阱与错误 (Gotchas)</h2>
<h3 id="51-prompt">5.1 陷阱：Prompt 注入攻击日志系统</h3>
<p><strong>现象</strong>：用户输入包含了恶意的控制字符或伪造的 JSON 格式，导致日志解析器崩溃，或者在日志查看器中伪造了假日志。
<strong>调试技巧</strong>：永远不要相信用户输入。在记录日志前，对所有非结构化文本进行 <code>JSON.stringify</code> 转义，或者使用专门的 Log Sanitizer。不要直接把字符串拼接进 JSON 模版。</p>
<h3 id="52-context">5.2 陷阱：记录了过大的 Context</h3>
<p><strong>现象</strong>：Agent 的 Context Window 很大（如 128k tokens）。开发者在每一步都记录了完整的 <code>History</code>。
<strong>后果</strong>：日志体积爆炸，磁盘瞬间写满，网络带宽被占满，Trace 系统因为 Payload 过大而丢弃数据。
<strong>调试技巧</strong>：</p>
<ul>
<li><strong>截断</strong>：对于 Prompt，只记录 500 和后 500 字符。</li>
<li><strong>摘要</strong>：计算 Prompt 的 Hash 值记录下来，如果需要查看内容，去专门的 Blob 存储（S3）里找（如果开启了 Full Capture）。</li>
<li><strong>引用</strong>：只记录 <code>message_id</code>，不记录 <code>content</code>。</li>
</ul>
<h3 id="53-span">5.3 陷阱：Span 未正确关闭</h3>
<p><strong>现象</strong>：程序抛出异常，导致 <code>span.end()</code> 代码没执行。Trace 界面上出现大量“永不结束”的长条，导致统计数据严重失真。
<strong>调试技巧</strong>：这就体现了 IO Monad <code>bracket</code> (resource safe acquisition/release) 的价值。
<strong>Rule of Thumb</strong>：永远不要手动调用 <code>startSpan</code> 和 <code>endSpan</code>。<strong>必须</strong>使用 <code>withSpan</code> 这种接收回调函数（Callback/Lambda）的 API，利用语言层面的 <code>finally</code> 或 Monad 的 <code>bracket</code> 机制保证关闭。</p>
<h3 id="54-tracing-eval">5.4 陷阱：混淆了 "Tracing" 和 "Eval"</h3>
<p><strong>现象</strong>：试图在 Trace 系统里做复杂的 Prompt 效果分析。
<strong>区别</strong>：Trace 是<strong>实时</strong>的、面向<strong>过程</strong>的（它挂了吗？慢吗？）。Eval 是<strong>离线</strong>的、面向<strong>质量</strong>的（回答得好吗？）。
<strong>建议</strong>：Trace 系统只负责把原始数据 dump 下来。复杂的质量分析（如“这个 Prompt 修改是否提高了准确率”）应该在专门的数据仓库或 Eval 平台（如 LangSmith, LangFuse）中离线进行。</p>
            </article>
            
            <nav class="page-nav"><a href="chapter8.html" class="nav-link prev">← Chapter 8 — A/B Test 与评估：把实验嵌进 IO/Kleisli 管道</a><a href="chapter10.html" class="nav-link next">Chapter 10 — 与 FRP 的关系：当 Agent 变成“事件流处理器” (chapter10.md) →</a></nav>
        </main>
    </div>
</body>
</html>