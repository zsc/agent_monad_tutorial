<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="./">
    <title>Chapter 8 — A/B Test 与评估：把实验嵌进 IO/Kleisli 管道</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/highlight.css">
    <script src="assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebar-search-input" placeholder="搜索..." autocomplete="off">
            </div>
            <div id="tree-container">
                <nav class="tree-nav" role="tree">
                    <div class="tree-item " >
                        <a href="index.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">《用 IO Monad 搭建 LLM Agent：从 Kleisli 到事件建模与 FRP》目录（index.md）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter1.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 1 — LLM Agent 的“抽象边界”：为什么从 IO Monad 出发</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter2.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 2 — IO Monad 速成：从概念到工程实现</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter3.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 3 — Kleisli Arrow：把“带 IO 的函数”当作可组合箭头</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter4.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 4 — Agent DSL：把工具、记忆与控制流做成“可解释的 effect”</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter5.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 5 — Runtime 与调度：从解释器到并发、取消与资源管理 (chapter5.md)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter6.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 6 — 事件建模：IO timeout、重试、退避、熔断与预算</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter7.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 7 — Coding Agent 的 Loop Detection：让 Agent 可终止、可解释</span>
                        </a>
                    </div>
                
                    <div class="tree-item active" >
                        <a href="chapter8.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 8 — A/B Test 与评估：把实验嵌进 IO/Kleisli 管道</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter9.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 9 — 可观测性：Trace/Span、日志、指标与可复现</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter10.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 10 — 与 FRP 的关系：当 Agent 变成“事件流处理器” (chapter10.md)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter11.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 11 — 综合案例：实现一个可插拔的 Coding Agent (chapter11.md)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter12.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 12 — 扩展阅读与路线图：通往类型安全与生产环境的彼岸</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter13.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 13 — 附录：终极参考手册 (The Ultimate Reference)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter14.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 14 — Search API + RAG：构建检索增强的 RAG Agent</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="CLAUDE.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                </nav>
            </div>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="chapter-8-ab-test-iokleisli">Chapter 8 — A/B Test 与评估：把实验嵌进 IO/Kleisli 管道</h1>
<h2 id="1">1. 开篇段落：从“运气”到“科学”</h2>
<p>在构建 LLM Agent 时，工程师往往面临一种无力感：Agent 的表现似乎高度依赖“运气”。修改了 Prompt 中的一个标点符号，在这个 Case 上变好了，却在另外十个 Case 上崩溃了。这种非确定性（Non-determinism）使得传统的单元测试（Unit Test）捉襟见肘。</p>
<p><strong>为什么 Agent 评估这么难？</strong></p>
<ol>
<li><strong>概率本质</strong>：LLM 是概率模型，同样的输入可能导致不同的输出。</li>
<li><strong>副作用依赖</strong>：Agent 依赖外部工具（搜索、数据库），环境本身在变。</li>
<li><strong>高昂成本</strong>：无法像传统软件那样每秒运行上万次测试。</li>
</ol>
<p>本章的核心理念是：<strong>不要把实验（Experimentation）当作代码写完后“外挂”的监控系统，而要将其视为 Agent 运行时不可或缺的一个 Effect（副作用）。</strong></p>
<p>我们将利用 <strong>IO Monad</strong> 的“纯描述”特性，构建可回放的、时间旅行般的评估系统；利用 <strong>Kleisli Arrow</strong> 的组合特性，在不侵入业务逻辑的前提下，像搭积木一样插入 A/B 分流器。无论是在线分流（Online Routing），还是离线反事实评估（Offline Counterfactual Evaluation），都将统一在同一个类型签名之下。</p>
<hr />
<h2 id="2">2. 文字论述</h2>
<h3 id="21-effect-experimentation-as-an-effect">2.1 实验即 Effect (Experimentation as an Effect)</h3>
<p>在传统的微服务架构中，A/B 测试通常通过一个全局的 <code>ExperimentClient</code> 单例来实现。但在函数式编程（FP）和 Agent 架构中，我们追求显式的依赖管理。</p>
<p>我们将“获取实验配置”定义为一种代数能力（Algebraic Ability）：</p>
<p>这意味着，任何需要做实验的代码段，都在类型签名上显式声明了它依赖 <code>Experiment</code> 能力。</p>
<ul>
<li><strong>Production Interpreter</strong>：计算哈希或调用 Redis/LaunchDarkly 获取分流结果。</li>
<li><strong>Test Interpreter</strong>：总是返回 <code>Control</code> 组，或根据测试用例强制返回 <code>Variant</code>。</li>
<li><strong>Replay Interpreter</strong>：从历史日志中读取当时分配的分组，确保回放的一致性。</li>
</ul>
<h3 id="22-kleisli">2.2 Kleisli 管道中的“铁路道岔”</h3>
<p>在 Chapter 3 中，我们将 Agent 建模为 Kleisli Arrow：<code>Input -&gt; M Output</code>。
A/B 测试本质上是一个<strong>动态路由组合子（Combinator）</strong>。</p>
<h4 id="221">2.2.1 路由结构图解</h4>
<p>想象 Agent 的处理流程是一条铁路，A/B 测试就是道岔。</p>
<div class="codehilite"><pre><span></span><code><span class="k">[ User Input ]</span>
<span class="w">      </span><span class="na">|</span>
<span class="w">      </span><span class="na">v</span>
<span class="na">(Pre-processing)</span>
<span class="w">      </span><span class="na">|</span>
<span class="w">      </span><span class="na">+------------------------+ (Decision Point</span><span class="o">:</span><span class="w"> </span><span class="s">assign effect)</span>
<span class="w">      </span><span class="na">|                        |</span>
<span class="k">[ Variant A: &quot;Reasoning&quot; ] [ Variant B: &quot;ReAct&quot; ]</span>
<span class="na">( Chain-of-Thought )       ( Direct Tool Use )</span>
<span class="w">      </span><span class="na">|                        |</span>
<span class="w">      </span><span class="na">+-----------+------------+</span>
<span class="w">                  </span><span class="na">|</span>
<span class="w">                  </span><span class="na">v</span>
<span class="w">         </span><span class="na">( Action Execution )</span>
<span class="w">                  </span><span class="na">|</span>
<span class="w">                  </span><span class="na">v</span>
<span class="w">             </span><span class="k">[ Output ]</span>
</code></pre></div>

<h4 id="222">2.2.2 代码语义（伪代码）</h4>
<p>我们可以定义一个高阶函数 <code>experiment</code>，它接受两个 Kleisli Arrow，并返回一个新的 Kleisli Arrow：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">-- 这是一个组合子，它把实验逻辑“编织”进管道中</span>
<span class="nf">experiment</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="p">(</span><span class="kt">Monad</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span>
<span class="w">           </span><span class="ow">=&gt;</span><span class="w"> </span><span class="kt">ExperimentID</span><span class="w"> </span>
<span class="w">           </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Kleisli</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w">  </span><span class="c1">-- Control (A组策略)</span>
<span class="w">           </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Kleisli</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w">  </span><span class="c1">-- Treatment (B组策略)</span>
<span class="w">           </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Kleisli</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">b</span><span class="w">  </span><span class="c1">-- 返回一个具备分流能力的箭头</span>
<span class="nf">experiment</span><span class="w"> </span><span class="n">expId</span><span class="w"> </span><span class="n">control</span><span class="w"> </span><span class="n">treatment</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Kleisli</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="nf">\</span><span class="n">input</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span>
<span class="w">    </span><span class="c1">-- 1. 获取分流上下文 (如 UserID)</span>
<span class="w">    </span><span class="n">ctx</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">askContext</span><span class="w"> </span>
<span class="w">    </span><span class="c1">-- 2. 执行 assign Effect</span>
<span class="w">    </span><span class="n">variant</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="kt">Effect</span><span class="o">.</span><span class="n">assign</span><span class="w"> </span><span class="n">expId</span><span class="w"> </span><span class="n">ctx</span>
<span class="w">    </span><span class="c1">-- 3. 根据结果选择路径</span>
<span class="w">    </span><span class="kr">case</span><span class="w"> </span><span class="n">variant</span><span class="w"> </span><span class="kr">of</span>
<span class="w">        </span><span class="kt">Control</span><span class="w">   </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">runKleisli</span><span class="w"> </span><span class="n">control</span><span class="w"> </span><span class="n">input</span>
<span class="w">        </span><span class="kt">Treatment</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="n">runKleisli</span><span class="w"> </span><span class="n">treatment</span><span class="w"> </span><span class="n">input</span>
</code></pre></div>

<p>这种写法的巨大优势在于<strong>局部性（Locality）</strong>：你不需要复制整个 Agent 代码，只需要在 Prompt 构建、工具选择或特定的决策步骤上应用 <code>experiment</code> 组合子。</p>
<h3 id="23-counterfactual-evaluation">2.3 离线回放与反事实评估 (Counterfactual Evaluation)</h3>
<p>这是 IO Monad 架构的杀手级应用。</p>
<p><strong>问题</strong>：线上跑了 10,000 条数据（使用 V1 策略）。现在我想知道，如果当时用 V2 策略，效果会怎样？
<strong>困难</strong>：V2 策略可能会产生不同的工具调用参数。如果 V1 搜索了 "Apple price"，V2 搜索了 "Apple stock"，我们无法知道 "Apple stock" 的结果，因为那件事在历史上没发生。</p>
<p><strong>基于 IO Monad 的解决方案</strong>：</p>
<p>我们需要构建一个 <strong>Cached/Mock Interpreter</strong>。</p>
<ol>
<li>
<p><strong>Trace Recording (录制)</strong>：
在线上运行时，记录所有的 <code>(StepInput, StepOutput)</code> 以及所有的 <code>(ToolRequest, ToolResponse)</code>。这构成了我们的“世界快照”。</p>
</li>
<li>
<p><strong>Simulation (回放)</strong>：
在离线环境加载 V2 版本的代码，注入录制好的 Log。</p>
</li>
</ol>
<ul>
<li>
<p><strong>情况 A：路径重合 (Convergence)</strong>
V2 想要调用 <code>Search("Apple price")</code>。解释器查表发现 V1 做过完全一样的调用，于是直接返回历史记录中的 <code>"150 USD"</code>。
<em>结论</em>：在这个分支上，我们可以安全地评估 V2。</p>
</li>
<li>
<p><strong>情况 B：路径偏离 (Divergence/Drift)</strong>
V2 想要调用 <code>Search("Apple stock")</code>。解释器查表发现 V1 没做过这个。
<em>处置</em>：</p>
</li>
<li>
<p><strong>保守策略</strong>：抛出 <code>DriftDetected</code> 异常，放弃该样本的评估。</p>
</li>
<li><strong>激进策略</strong>：如果有模拟器（Simulator），尝试模拟结果；否则必须终止。</li>
</ul>
<p><strong>Rule of Thumb</strong>：</p>
<blockquote>
<p>只要 Agent 的决策逻辑（Policy）变化没有导致外部副作用（External Effect）的参数变化，离线回放就是 100% 准确的。
<em>适用场景</em>：Prompt 微调、格式修正、提取逻辑优化。</p>
</blockquote>
<h3 id="24-interleaving">2.4 Interleaving：生成式模型的特有竞技场</h3>
<p>对于生成内容（如写邮件、写代码），人类很难给出一个绝对分数。但是，人类非常擅长<strong>比较</strong>。
<strong>Interleaving（错）</strong> 是一种特殊的 A/B 测试形态。</p>
<p><strong>机制</strong>：</p>
<ol>
<li>用户发来请求。</li>
<li>系统<strong>并发（Concurrency）</strong> 运行 Agent V1 和 Agent V2（利用 <code>parZip</code> 或 <code>race</code> combinator）。</li>
<li>系统将两个结果 A 和 B 展示给用户（位置随机打乱）。</li>
<li>用户选择了一个。</li>
</ol>
<p><strong>IO 建模</strong>：</p>
<div class="codehilite"><pre><span></span><code><span class="c1">-- 并发运行两个 Kleisli，并在 IO 层收集结果</span>
<span class="nf">interleave</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Kleisli</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="kt">In</span><span class="w"> </span><span class="kt">Out</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Kleisli</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="kt">In</span><span class="w"> </span><span class="kt">Out</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kt">Kleisli</span><span class="w"> </span><span class="kt">IO</span><span class="w"> </span><span class="kt">In</span><span class="w"> </span><span class="p">(</span><span class="kt">Out</span><span class="p">,</span><span class="w"> </span><span class="kt">Out</span><span class="p">)</span>
<span class="nf">interleave</span><span class="w"> </span><span class="n">k1</span><span class="w"> </span><span class="n">k2</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Kleisli</span><span class="w"> </span><span class="o">$</span><span class="w"> </span><span class="nf">\</span><span class="n">input</span><span class="w"> </span><span class="ow">-&gt;</span><span class="w"> </span><span class="kr">do</span>
<span class="w">    </span><span class="c1">-- 并行执行，利用 IO 的异步能力</span>
<span class="w">    </span><span class="p">(</span><span class="n">res1</span><span class="p">,</span><span class="w"> </span><span class="n">res2</span><span class="p">)</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">parZip</span><span class="w"> </span><span class="p">(</span><span class="n">runKleisli</span><span class="w"> </span><span class="n">k1</span><span class="w"> </span><span class="n">input</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">runKleisli</span><span class="w"> </span><span class="n">k2</span><span class="w"> </span><span class="n">input</span><span class="p">)</span>
<span class="w">    </span><span class="n">return</span><span class="w"> </span><span class="p">(</span><span class="n">res1</span><span class="p">,</span><span class="w"> </span><span class="n">res2</span><span class="p">)</span>
</code></pre></div>

<p>这种方法能极快地收敛出“哪个模型更好”，因为它消除了用户间的方差（User Variance）。</p>
<hr />
<h2 id="3">3. 本章小结</h2>
<ol>
<li><strong>Experiment as Effect</strong>：将 A/B 分流视为抽象的副作用接口，解耦业务逻辑与实验配置。</li>
<li><strong>Kleisli Routing</strong>：实验是计算管道中的分支节点，利用组合子保持代码整洁。</li>
<li><strong>Causal Validity</strong>：离线评估的核心挑战是处理“反事实路径”的缺失。利用 IO Monad 的录制/回放机制，我们可以精确捕捉路径偏离（Drift）。</li>
<li><strong>Metric Hierarchy</strong>：建立从“代码不崩”（Crash Rate）到“用户爱用”（Retention）再到“模型智能”（LLM-as-a-Judge）的多层指标体系。</li>
</ol>
<hr />
<h2 id="4">4. 练习题</h2>
<h3 id="_1">基础题</h3>
<p><strong>Q1. 实验 ID 与上下文设计的陷阱</strong>
我们需要实现 <code>assign</code> 函数。为了保证实验结果在统计上有效，我们需要对 UserID 进行 Hash。
请问：为什么简单的 <code>hash(UserID) % 100</code> 是不够的？如果在同一个 User 身上同时运行两个独立的实验（比如 UI 颜色实验和 Agent Prompt 实验），会发生什么问题？</p>
<details>
<summary>点击查看提示与参考答案</summary>
<ul>
<li><strong>Hint</strong>: 思考“相关性”（Correlation）。如果一个 ID 的哈希值总是落在低区间，他是否总是会被分到所有实验的 Control 组？</li>
<li><strong>Answer</strong>:</li>
<li><strong>问题</strong>：如果所有实验共享同一个哈希算法且没有盐（Salt），那么 UserID 哈希值较小的用户将永远被分入所有实验的“前 50%”桶中。这导致实验之间产生强耦合（Orthogonality Violation），无法区分是 UI 变了导致效果好，还是 Prompt 变了导致效果好。</li>
<li><strong>解决</strong>：必须引入 <strong>Salt</strong>。公式应为 <code>hash(UserID + ExperimentID) % 100</code>。这样同一个用户在实验 A 中是 Control，在实验 B 中可能是 Variant，保证了正交性。</li>
</ul>
</details>
<p><strong>Q2. 指标收集的组合性</strong>
假设你有一个 metric 叫 <code>token_usage</code>。请用自然语言描述，如何利用 Writer Monad（或类似的累加器结构）在不修改 LLM 调用函数内部代码的前提下，统计一次完整 Agent 交互的总 Token 数？</p>
<details>
<summary>点击查看提示与参考答案</summary>
<ul>
<li><strong>Hint</strong>: 装饰器模式。<code>FlatMap</code> 的结合律。</li>
<li><strong>Answer</strong>:</li>
<li>定义一个 Wrapper 函数，它接受一个 <code>LLMCall</code> 动作。</li>
<li>在这个 Wrapper 执行完 <code>LLMCall</code> 后，解析返回结果中的 <code>usage</code> 字段。</li>
<li>调用 <code>tell(Usage(tokens))</code> 将其写入 Writer Monad 的日志流。</li>
<li>由于 Writer Monad 具备 Monoid 性质（可结合），在外层运行整个 Agent Pipeline 时，所有步骤产生的 <code>Usage</code> 会自动相加，最终得到总和。</li>
</ul>
</details>
<p><strong>Q3. 简单的哈希分流实现</strong>
编写一个伪代码函数 <code>get_bucket(user_id, experiment_salt, total_buckets=100)</code>，要求输出确定性且均匀分布。</p>
<details>
<summary>点击查看提示与参考答案</summary>
<ul>
<li><strong>Hint</strong>: MD5/SHA256, Hex string to Int.</li>
<li><strong>Answer</strong>:</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="nn">hashlib</span>
<span class="k">def</span> <span class="nf">get_bucket</span><span class="p">(</span><span class="n">user_id</span><span class="p">,</span> <span class="n">salt</span><span class="p">,</span> <span class="n">total_buckets</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
    <span class="n">raw</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">user_id</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">salt</span><span class="si">}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span>
    <span class="c1"># 使用 SHA256 获取均匀分布的哈希</span>
    <span class="n">hex_hash</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha256</span><span class="p">(</span><span class="n">raw</span><span class="p">)</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
    <span class="c1"># 取前 8 位（32-bit int）即可</span>
    <span class="n">int_val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">hex_hash</span><span class="p">[:</span><span class="mi">8</span><span class="p">],</span> <span class="mi">16</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">int_val</span> <span class="o">%</span> <span class="n">total_buckets</span>
</code></pre></div>

</details>
<hr />
<h3 id="_2">挑战题</h3>
<p><strong>Q4. 离线回放中的“确定性消除”</strong>
在离线回放 V2 Prompt 时，V2 请求生成一个随机数（比如“从 1 到 10 选一个数作为重试等待时间”）。历史日志里的 V1 也生成过随机数，但是是 7。V2 现在的代码跑起来生成了 3。这会导致后续的行为不一致。
如何利用 IO Monad 的思想，在<strong>不修改业务代码</strong>的情况下，强行让 V2 在回放时也得到 7？</p>
<details>
<summary>点击查看提示与参考答案</summary>
<ul>
<li><strong>Hint</strong>: 随机数生成器（RNG）本身应该是一个 Effect 吗？</li>
<li><strong>Answer</strong>:</li>
<li><strong>核心思想</strong>：必须将 <code>Random</code> 建模为 Effect，而不是直接调用 <code>Math.random()</code>。</li>
<li><strong>抽象</strong>：定义 <code>trait Random { def nextInt(n: Int): IO[Int] }</code>。</li>
<li><strong>录制</strong>：在线上 <code>RealRandomInterpreter</code> 中，每次调用 <code>nextInt</code>，不仅返回随机数，还将其记录到 Trace Log 中（顺序敏感）。</li>
<li><strong>回放</strong>：在离线 <code>ReplayRandomInterpreter</code> 中，维护一个指向 Log 的游标。每次业务代码请求随机数，直接弹出 Log 中的下一个值返回。这样就消除了随机性带来的偏差。</li>
</ul>
</details>
<p><strong>Q5. 实验的“污染”与状态隔离</strong>
在一个长 Session 中，我们在第 3 轮对话时开启了实验 <code>Memory_V2</code>（一种新的记忆压缩算法）。用户聊了 10 轮。
第 11 轮时，用户重置了 Session，但后端为了省钱，复用了同一个 Vector DB 的 Namespace。
请问：之前的实验数据会对新的 Session 造成什么影响？在架构层面如何规避？</p>
<details>
<summary>点击查看提示与参考答案</summary>
<ul>
<li><strong>Hint</strong>: 副作用的范围控制。Resource management (<code>bracket</code>).</li>
<li><strong>Answer</strong>:</li>
<li><strong>影响</strong>：这叫 <strong>Carryover Effect（残留效应）</strong>。<code>Memory_V2</code> 产生的压缩记忆格式可能与默认版本不兼容，或者其包含的信息偏置会影响后续标准版本的表现。</li>
<li><strong>架构规避</strong>：
1. <strong>Ephemeral Sandbox</strong>：对于实验流量，使用临时的、带 TTL（Time-To-Live）的存储空间。
2. <strong>Logic Separation</strong>：在 Vector DB 的 Metadata 中打上 <code>algo_version: v2</code> 标签。读取时，标准版本代码必须显式过滤掉 <code>algo_version != v1</code> 的记忆。
3. <strong>IO Bracket</strong>：利用 <code>bracket(setup, teardown, use)</code> 模式。在实验 Session 结束时（<code>teardown</code>），自动触发清理逻辑，物理删除该实验产生的所有脏状态。</li>
</ul>
</details>
<p><strong>Q6. 多臂老虎机 (Multi-Armed Bandit) 的 Effect 建模</strong>
如果我们不仅想要 A/B Test，还想要自动化的 Thompson Sampling（谁效果好就多给谁流量）。
这要求我们的 <code>Assign</code> Effect 不再是纯函数式的哈希，而是依赖全局可变状态。请设计这个 Effect 的接口，以及一个用于反馈奖励（Reward）的接口。</p>
<details>
<summary>点击查看提示与参考答案</summary>
<ul>
<li><strong>Hint</strong>: 这是一个闭环系统：Route -&gt; Act -&gt; Reward -&gt; Update Model。</li>
<li><strong>Answer</strong>:</li>
<li><strong>接口设计</strong>：</li>
</ul>
<div class="codehilite"><pre><span></span><code><span class="k">trait</span><span class="w"> </span><span class="nc">Bandit</span><span class="p">[</span><span class="nc">M</span><span class="p">[</span><span class="n">_</span><span class="p">]]</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="c1">// 获取臂（Arm），可能涉及读取共享存储或调用外部 Bandit Service</span>
<span class="w">   </span><span class="k">def</span><span class="w"> </span><span class="nf">selectArm</span><span class="p">(</span><span class="n">feature</span><span class="p">:</span><span class="w"> </span><span class="nc">Context</span><span class="p">):</span><span class="w"> </span><span class="nc">M</span><span class="p">[</span><span class="nc">Arm</span><span class="p">]</span><span class="w"> </span>
<span class="w">   </span><span class="c1">// 反馈奖励，用于更新模型权重</span>
<span class="w">   </span><span class="k">def</span><span class="w"> </span><span class="nf">reportReward</span><span class="p">(</span><span class="n">arm</span><span class="p">:</span><span class="w"> </span><span class="nc">Arm</span><span class="p">,</span><span class="w"> </span><span class="n">reward</span><span class="p">:</span><span class="w"> </span><span class="nc">Double</span><span class="p">):</span><span class="w"> </span><span class="nc">M</span><span class="p">[</span><span class="nc">Unit</span><span class="p">]</span><span class="w"> </span>
<span class="p">}</span>
</code></pre></div>

<ul>
<li><strong>集成点</strong>：</li>
<li><code>selectArm</code> 发生在 Agent 启动前。</li>
<li>
<p><code>reportReward</code> 发生在 Agent 结束后的评估阶段（可能通过人工点赞，或自动化判题机）。</p>
</li>
<li>
<p><strong>注意</strong>：在 IO Monad 中，这通常意味着 <code>Experiment</code> 解释器需要持有 Redis 连接或数据库句柄来同步权重状态。</p>
</li>
</ul>
</details>
<p><strong>Q7. 嵌套实验 (Nested Experiments) 的正交性验证</strong>
你同时跑了“Prompt 变体”和“RAG 检索参数”两个实验。
离线分析时，你发现 Prompt A 组的平均响应时间比 B 组慢了 500ms。但是，仔细检查发现，Prompt A 组里恰好有 80% 的请求命中了“RAG 慢速检索”组（由于哈希碰撞或配置错误）。
作为架构师，你如何通过 Log/Trace 数据结构设计，来一眼识破这种“混杂偏差（Confounding Bias）”？</p>
<details>
<summary>点击查看提示与参考答案</summary>
<ul>
<li><strong>Hint</strong>: 结构化日志。Canonical Log Line。</li>
<li><strong>Answer</strong>:</li>
<li><strong>设计</strong>：必须在每一个 Request 的最终日志（Canonical Log）中，包含一个 <strong>Experiments Map</strong> 字段。</li>
<li><strong>结构</strong>：<code>{"prompt_exp": "variant_A", "rag_exp": "slow_mode", ...}</code></li>
<li><strong>验证</strong>：在分析阶段，进行 <strong>卡方检验 (Chi-Square Test)</strong>。构建一个列联表（Contingency Table），检查 <code>Prompt Variant</code> 和 <code>RAG Variant</code> 的分布是否独立。如果 ，说明两个实验分配不独立，存在 Bug，此时不能直接比较单因素指标。</li>
</ul>
</details>
<hr />
<h2 id="5-gotchas">5. 常见陷阱与错误 (Gotchas)</h2>
<ol>
<li>
<p><strong>Peeking (偷看) 导致的假阳性</strong>
* <em>现象</em>：每跑完 100 个 Case 就跑一次 T 检验，一旦显著就宣布胜利。
* <em>原理</em>：多次检验会累积 Type I Error。
* <em>Rule of Thumb</em>：预先确定样本量（Sample Size），或者使用 <strong>序贯概率比检验 (SPRT)</strong> 方法。</p>
</li>
<li>
<p><strong>缓存击穿实验 (Caching Bias)</strong>
* <em>场景</em>：Agent 框架为了快，在底层加了 Semantic Cache。
* <em>Bug</em>：User A (Group Control) 问了“天气”，缓存了结果。User B (Group Variant) 问了“天气”，直接拿到了 Control 组生成的答案。
* <em>修复</em>：Cache Key 必须包含 <code>Variant Hash</code>。
* <em>公式</em>：<code>Key = Hash(Prompt + UserInput + ActiveExperimentVariants)</code>。</p>
</li>
<li>
<p><strong>把“错误”当成“负样本” (Survivorship Bias)</strong>
* <em>现象</em>：新模型 V2 代码有 Bug，处理复杂问题时直接 Crash（不返回结果）。简单的能处理。
* <em>数据</em>：统计“所有成功返回的对话”的质量，发现 V2 均分很高（因为它只处理了简单题）。
* <em>修复</em>：任何 Crash 或 Timeout 都必须被视为 <strong>最低分（0分）</strong> 纳入平均分计算。分母必须是 <code>Assigned Count</code> 而不是 <code>Completed Count</code>。</p>
</li>
<li>
<p><strong>Prompt 只有微小改动时的“盲目自信”</strong>
* <em>误区</em>：“我只加了一句 'Think step by step'，肯定变强，不用测了直接上。”
* <em>现实</em>：LLM 对 Prompt 极其敏。这句话可能导致 JSON 输出格式错误率增加 10%，或者导致回复长度倍增从而触发 Token Limit 截断。
* <em>建议</em>：所有 Prompt 变更都是代码变更，必须过回放测试。</p>
</li>
</ol>
            </article>
            
            <nav class="page-nav"><a href="chapter7.html" class="nav-link prev">← Chapter 7 — Coding Agent 的 Loop Detection：让 Agent 可终止、可解释</a><a href="chapter9.html" class="nav-link next">Chapter 9 — 可观测性：Trace/Span、日志、指标与可复现 →</a></nav>
        </main>
    </div>
</body>
</html>