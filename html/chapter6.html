<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="./">
    <title>Chapter 6 — 事件建模：IO timeout、重试、退避、熔断与预算</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/highlight.css">
    <script src="assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebar-search-input" placeholder="搜索..." autocomplete="off">
            </div>
            <div id="tree-container">
                <nav class="tree-nav" role="tree">
                    <div class="tree-item " >
                        <a href="index.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">《用 IO Monad 搭建 LLM Agent：从 Kleisli 到事件建模与 FRP》目录（index.md）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter1.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 1 — LLM Agent 的“抽象边界”：为什么从 IO Monad 出发</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter2.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 2 — IO Monad 速成：从概念到工程实现</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter3.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 3 — Kleisli Arrow：把“带 IO 的函数”当作可组合箭头</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter4.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 4 — Agent DSL：把工具、记忆与控制流做成“可解释的 effect”</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter5.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 5 — Runtime 与调度：从解释器到并发、取消与资源管理 (chapter5.md)</span>
                        </a>
                    </div>
                
                    <div class="tree-item active" >
                        <a href="chapter6.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 6 — 事件建模：IO timeout、重试、退避、熔断与预算</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter7.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 7 — Coding Agent 的 Loop Detection：让 Agent 可终止、可解释</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter8.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 8 — A/B Test 与评估：把实验嵌进 IO/Kleisli 管道</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter9.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 9 — 可观测性：Trace/Span、日志、指标与可复现</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter10.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 10 — 与 FRP 的关系：当 Agent 变成“事件流处理器” (chapter10.md)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter11.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 11 — 综合案例：实现一个可插拔的 Coding Agent (chapter11.md)</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter12.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Chapter 12 — 扩展阅读与路线图：通往类型安全与生产环境的彼岸</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="CLAUDE.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                </nav>
            </div>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="chapter-6-io-timeout">Chapter 6 — 事件建模：IO timeout、重试、退避、熔断与预算</h1>
<h2 id="1">1. 开篇段落</h2>
<p>在构建简单的 Demo Agent 时，我们往往假设一切顺利：API 总是毫秒级响应，JSON 格式总是完美无缺，Token 永远够用。但在生产环境中，<strong>LLM Agent 本质上是一个运行在不可靠基础设施上的、概率性的分布式系统</strong>。</p>
<p>LLM 的不确定性（幻觉、格式错误）叠加网络的不确定性（超时、断连），如果不加以控制，会使 Agent 变成一个脆弱的玩具。在面向对象编程中，我们习惯用 <code>try-catch</code> 满地打补丁，这导致核心业务逻辑（Agent 的思考过程）被错误处理代码淹没。</p>
<p>本章的目标是利用 <strong>IO Monad</strong> 的组合特性，将这些“故障与约束”建模为<strong>一等公民（First-class values）</strong>。我们将不再“处理”异常，而是通过组合子（Combinators）构建一个<strong>自带弹性（Resilient）</strong>的运行时环境。你将学会如何用纯函数式的方式描述“在预算内、带有指数退避重试、且受熔断器保护的 LLM 调用”。</p>
<hr />
<h2 id="2">2. 文字论述</h2>
<h3 id="21">2.1 范式转换：从“异常”到“代数数据类型”</h3>
<p>在 IO Monad 的世界里，错误不是代码执行流的“中断”，而是数据流的一个“分支”。</p>
<ul>
<li><strong>传统视角</strong>：调用 <code>callLLM()</code>，如果网络断了，抛出 <code>NetworkException</code>，栈回溯，程序崩溃或跳转。</li>
<li><strong>IO 视角</strong>：<code>callLLM</code> 的返回值类型明确告诉了你结果的可能性。</li>
<li><code>IO (Either Error String)</code>: 明确指出了可能失败。</li>
<li><code>IO (Option String)</code>: 明确指出了可能无结果（如超时）。</li>
</ul>
<p>这种显式建模强迫开发者在<strong>编译期</strong>（或编写逻辑时）就处理所有分支，而不是等到运行时 crash。</p>
<h3 id="22-timeout">2.2 Timeout：时间的边界与取消语义</h3>
<p>超时不仅仅是“时间到了就报错”，它涉及到底层的<strong>资源回收</strong>与<strong>取消语义（Cancellation）</strong>。</p>
<h4 id="221-race">2.2.1 竞态模型（Race）</h4>
<p><code>timeout</code> 本质上是两个 IO 操作的竞态：</p>
<ol>
<li><strong>Task A</strong>: 你的业务逻辑（如 LLM 推理）。</li>
<li><strong>Task B</strong>: 一个睡眠  秒的计时器。</li>
</ol>
<div class="codehilite"><pre><span></span><code>       +--- Task A (LLM) ----&gt; Result A
Start -+
       +--- Task B (Timer) --&gt; Result B (Timeout)
</code></pre></div>

<p>使用 <code>race</code> 组合子，谁先完成，就取谁的结果，并<strong>取消（Cancel）</strong>另一个正在运行的任务。这要求底层的 IO Runtime 支持“中断”操作（例如关闭 HTTP Socket，释放显存）。</p>
<h4 id="222-deadline-vs-timeout">2.2.2 绝对截止时间 (Deadline) vs 相对超时 (Timeout)</h4>
<ul>
<li><strong>Timeout (<code>duration</code>)</strong>: 相对时间。每次重试都会重置计时器。</li>
<li>
<p><em>风险</em>：如果重试 10 次，每次 10 秒，总耗时可能达到 100 秒，拖死上游。</p>
</li>
<li>
<p><strong>Deadline (<code>instant</code>)</strong>: 绝对时间点。</p>
</li>
<li><em>优势</em>：更好的组合性。无论内部怎么重试，Deadline 就像一道不可逾越的墙，到了时间点必须全局终止。</li>
</ul>
<h3 id="23-retry-backoff">2.3 Retry 与 Backoff：避免“惊群效应”</h3>
<p>当 Agent 遇到故障时，立即重试往往是错误的。</p>
<h4 id="231-backoff">2.3.1 为什么需要 Backoff（退避）？</h4>
<p>如果一个后端服务暂时过载，成千上万个 Agent 同时发起重试，会瞬间将刚恢复的服务再次打垮。这被称为<strong>惊群效应（Thundering Herd）</strong>。
解决方案是<strong>指数退避（Exponential Backoff）</strong>：</p>
<h4 id="232-jitter">2.3.2 为什么必须加 Jitter（抖动）？</h4>
<p>即使有了指数退避，如果所有 Agent 都在同一时刻（T=0）失败，它们会在 T=2, T=4, T=8 同时醒来重试，形成<strong>波峰共振</strong>。
<strong>Full Jitter</strong> 算法是目前的最佳实践：</p>
<p>在 IO Monad 中，随机数生成也是一种副作用（Effect），需要被封装在 <code>Rand</code> 或 <code>IO</code> 中。</p>
<h3 id="24-circuit-breaker">2.4 Circuit Breaker（熔断器）：保护系统</h3>
<p>重试解决的是“暂时性故障，但如果 LLM 服务彻底挂了，或者 Agent 的 Prompt 有严重的逻辑漏洞导致 100% 报错，无限重试就是在浪费预算。</p>
<p>熔断器是一个<strong>状态机</strong>，通常通过 <code>MVar</code> 或 <code>Ref</code>（可变引用）实现：</p>
<div class="codehilite"><pre><span></span><code>[Closed] --(Failure &gt; Threshold)--&gt; [Open]
   ^                                   |
   |                               (Sleep Window)
(Success)                              |
   |                                   v
[Half-Open] &lt;--(Allow 1 Request)-------+
</code></pre></div>

<ol>
<li><strong>Closed（闭合）</strong>：正常状态，请求直通。</li>
<li><strong>Open（断开）</strong>：错误率超标，立即短路所有请求（Fail Fast），不消耗网络和 Token。</li>
<li><strong>Half-Open（半开）</strong>：经过一段时间冷却，放行一个请求“探路”。成功则复位，失败则继续断开。</li>
</ol>
<h3 id="25-budgetingtoken">2.5 Budgeting（预算）：Token 即金钱</h3>
<p>Agent 极易陷入死循环或过度思考。我们需要构建一个 <strong>Budget Algebra（预算代数）</strong>。</p>
<h4 id="251">2.5.1 多维预算</h4>
<ul>
<li><strong>Hard Currency</strong>: 实际 API 开销（美元）。</li>
<li><strong>Token Count</strong>: 上下文窗口限制（防止溢出）。</li>
<li><strong>Step Count</strong>: 防止死循环（Loop）。</li>
</ul>
<h4 id="252">2.5.2 实现方式</h4>
<p>我们可以使用 <code>StateT</code> Monad Transformer 来隐式传递预算状态：</p>
<ul>
<li><code>checkBudget :: Cost -&gt; AppM ()</code></li>
<li>在执行任何 Tool 或 LLM 调用前，先运行 <code>checkBudget</code>。</li>
<li>如果余额不足，抛出特定错误，中断整个 Kleisli 管道。</li>
</ul>
<h3 id="26-the-onion-architecture">2.6 The Onion Architecture（洋葱架构）</h3>
<p>如何组合上述所有能力？利用高阶函数（Wrapper/Middleware）层层包裹。</p>
<div class="codehilite"><pre><span></span><code>Input 
  -&gt; [ Budget Check ]       &lt;-- 没钱直接拒
    -&gt; [ Circuit Breaker ]  &lt;-- 下游挂了直接拒
      -&gt; [ Global Deadline ] &lt;-- 总时间控制
        -&gt; [ Retry Loop ]    &lt;-- 局部容错
          -&gt; [ Rate Limiter ] &lt;-- 避免超频
            -&gt; [ Trace Span ] &lt;-- 记录日志
              -&gt; [ Actual Effect (LLM/Tool) ]
</code></pre></div>

<p><strong>组合的顺序至关重要</strong>。例如，如果 <code>Timeout</code> 在 <code>Retry</code> 里面，就是“单请求超时重试”；如果 <code>Timeout</code> 在 <code>Retry</code> 外面，就是“总执行时间超时”。</p>
<hr />
<h2 id="3">3. 本章小结</h2>
<ul>
<li><strong>故障即值</strong>：用 <code>Either Error a</code> 代替异常，用 <code>Option a</code> 代替空指针/超时，让错误处理具备类型安全性。</li>
<li><strong>组合子模式</strong>：我们不修改 Agent 的核心逻辑，而是通过 <code>retry(policy, agent)</code>, <code>timeout(duration, agent)</code> 这样的包装器来增强它。</li>
<li><strong>退避三要素</strong>：<strong>Base</strong> (基准时间), <strong>Cap</strong> (最大时间), <strong>Jitter</strong> (随机抖动)。缺一不可。</li>
<li><strong>熔断器</strong>：是分布式系统的保险丝，防止错误的级联传播和资源的无效消耗。</li>
<li><strong>预算控制</strong>：必须作为一种强制的 Effect 贯穿整个生命周期，不仅仅是为了省钱，也是为了程序的<strong>可终止性（Termination）</strong>。</li>
</ul>
<hr />
<h2 id="4">4. 练习题</h2>
<h3 id="_1">基础题（熟悉概念与签名）</h3>
<p><strong>练习 6.1：Retry Policy 的代数定义</strong>
请定义一个数据结构 <code>RetryPolicy</code>，它能够描述以下策略：
"初始等待 1秒每次失败等待时间翻倍，最大等待 10秒，最多重试 5次"。
不需要写代码逻辑，只需要定义数据类型（Struct/Interface）。</p>
<details>
<summary>点击查看提示</summary>
<p>思考需要哪些字段来存储这些参数。</p>
</details>
<details>
<summary>参考答案</summary>
<div class="codehilite"><pre><span></span><code><span class="c1">-- 伪代码定义</span>
<span class="kr">data</span><span class="w"> </span><span class="kt">RetryPolicy</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">RetryPolicy</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">initialDelay</span><span class="w"> </span><span class="ow">::</span><span class="w"> </span><span class="kt">Duration</span><span class="p">,</span><span class="w">  </span><span class="c1">-- 1s</span>
<span class="w">    </span><span class="n">maxDelay</span><span class="w">     </span><span class="ow">::</span><span class="w"> </span><span class="kt">Duration</span><span class="p">,</span><span class="w">  </span><span class="c1">-- 10s</span>
<span class="w">    </span><span class="n">maxRetries</span><span class="w">   </span><span class="ow">::</span><span class="w"> </span><span class="kt">Int</span><span class="p">,</span><span class="w">       </span><span class="c1">-- 5</span>
<span class="w">    </span><span class="n">backoffBase</span><span class="w">  </span><span class="ow">::</span><span class="w"> </span><span class="kt">Double</span><span class="w">     </span><span class="c1">-- 2.0 (exponential)</span>
<span class="p">}</span>
<span class="c1">-- 注意：Jitter 通常由运行时的解释器决定，或者作为 Policy 的一个 Bool 开关。</span>
</code></pre></div>

</details>
<p><strong>练习 6.2：超时与返回类型</strong>
如果函数 <code>askLLM</code> 的类型是 <code>String -&gt; IO String</code>。
我们应用一个 5秒 的超时。请问新的函数类型签名应该是什么？
如果在这个基础上，我们再应用一个“捕获错误并返回默认值 'Error'” 的操作，新的类型签名又是什么？</p>
<details>
<summary>点击查看提示</summary>
<p>第一步引入了“可能无结果”的状态；第二步消除了这种可能性。</p>
</details>
<details>
<summary>参考答案</summary>
<ol>
<li>应用超时后：<code>String -&gt; IO (Option String)</code> 或 <code>String -&gt; IO (Maybe String)</code>。</li>
<li>应用默认值后：<code>String -&gt; IO String</code>。
* 逻辑：<code>IO (Option String)</code> -&gt; map (orElse "Error") -&gt; <code>IO String</code>。
* 这展示了类型系统如何跟踪错误处理的状态。</li>
</ol>
</details>
<p><strong>练习 6.3：计算 Token 预算</strong>
假设 Agent 初始预算为 1000 Tokens。
步骤 1: User Input (50 tokens) -&gt; 剩余 950。
步骤 2: Agent Tool Call (Input 100 + Output 50) -&gt; 剩余 ?
步骤 3: System Warning -&gt; 如果剩余 &lt; 100，停止。
请计算步骤 2 后的剩余预算，并说明为什么 Tool Call 的 Input 和 Output 都要计费。</p>
<details>
<summary>点击查看提示</summary>
<p>LLM 的计费通常是 (Prompt Tokens + Completion Tokens)。Tool Use 的过程，LLM 实际上是生成了 Tool 的调用指令（Output），然后你把结果作为新的 Prompt（Input）喂回去。</p>
</details>
<details>
<summary>参考答案</summary>
<p>步骤 2 后的剩余： Tokens。
<em>注意</em>：如果是 Tool Call 场景，通常意味着：LLM 生成调用代码（Output），Runtime 执行代码得到结果，结果被拼接到下一次的 Prompt 中（Input）。所以每一轮对话的累积上下文都在消耗预算。</p>
</details>
<h3 id="_2">挑战题（架构设计与深度思考）</h3>
<p><strong>练习 6.4：设计一个“智能”的重试策略</strong>
对于 LLM Agent，普通的指数退避可能不够。如果 LLM 返回 "Context Limit Exceeded"（上下文超长），简单的重试会永远失败。
请设计一个 <code>SmartRetry</code> 策略，它不仅看重试次数，还看<strong>错误类型</strong>。
请列出至少三种不同的错误类型，并给出对应的处理策略（Retry, Stop, or Modify）。</p>
<details>
<summary>点击查看提示</summary>
<p>分类错误：暂时性网络错误 vs 确定性逻辑错误 vs 资源配额错误。</p>
</details>
<details>
<summary>参考答案</summary>
<ol>
<li>
<p><strong>Transient Error (500/503/Timeout)</strong>:
* <em>Action</em>: 标准指数退避重试 (Exponential Backoff)。</p>
</li>
<li>
<p><strong>Context Limit Error (400 Bad Request)</strong>:
* <em>Action</em>: <strong>Modify &amp; Retry</strong>。执行“摘要（Summarize）”操作压缩历史记录，然后重试。</p>
</li>
<li>
<p><strong>Authentication Error (401)</strong>:
* <em>Action</em>: <strong>Stop</strong>。重试无效，立即报错并通知管理员。</p>
</li>
<li>
<p><strong>Rate Limit (429)</strong>:
* <em>Action</em>: <strong>Wait &amp; Retry</strong>。根据 Header 里的 <code>Retry-After</code> 字段精确等待，而不是盲目退避。</p>
</li>
</ol>
</details>
<p><strong>练习 6.5：实现 Circuit Breaker 的 State Monad</strong>
熔断器需要维护状态（失败计数、上次失败时间、当前状态）。如果我们在一个纯函数式环境（即变量不可变）中，不使用外部数据库，如何在一个长时间运行的 Agent Loop 中实现熔断器？
<em>提示：思考 <code>State</code> Monad 和递归循环的关系。</em></p>
<details>
<summary>点击查看提示</summary>
<p>在 FP 中，状态是通过函数参数“传递”下去的。</p>
</details>
<details>
<summary>参考答案</summary>
<p>我们需要将 CircuitBreaker 的状态 <code>CBState</code> 作为 Agent 运行时的 <code>StateT</code> 的一部分。
每次循环（Step）：</p>
<ol>
<li>解包当前的 <code>CBState</code>。</li>
<li>检查是否 Open。</li>
<li>如果 Open 且未到冷却时间，直接返回错误，状态不变。</li>
<li>
<p>如果 Closed，执行 Action。
* 成功：重置 <code>failureCount = 0</code>，返回新状态。
* 失败：<code>failureCount + 1</code>，如果超阈值则置为 Open，记录 <code>lastFailureTime</code>，返回新状态。</p>
</li>
<li>
<p>将新的 <code>CBState</code> 传递给下一次递归调用。</p>
</li>
</ol>
</details>
<p><strong>练习 6.6：预算耗尽的“优雅降级”</strong>
当 Token Budget 仅剩 5% 时，直接抛出异常终止对话体验很差。
请设计一个 Kleisli Arrow 流程，当 <code>BudgetCheck</code> 发现余额低时，不终止，而是<strong>动态切换</strong> Agent 的行为模式。</p>
<details>
<summary>点击查看提示</summary>
<p>这涉及到了控制流的分支。<code>if low_budget then finalize_strategy else normal_strategy</code>.</p>
</details>
<details>
<summary>参考答案</summary>
<p>定义两个策略：</p>
<ul>
<li><code>NormalStrategy</code>: 允许使用 Tool，允许深思熟虑。</li>
<li><code>WrapUpStrategy</code>: 禁用 Tool，强制 LLM 生成结语（"由于资源限制，我将总结当前进度..."）。</li>
</ul>
<p>组合逻辑：</p>
<div class="codehilite"><pre><span></span><code><span class="nf">runStep</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kr">do</span>
<span class="w">  </span><span class="n">budget</span><span class="w"> </span><span class="ow">&lt;-</span><span class="w"> </span><span class="n">getBudget</span>
<span class="w">  </span><span class="kr">if</span><span class="w"> </span><span class="n">budget</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">threshold</span>
<span class="w">     </span><span class="kr">then</span><span class="w"> </span><span class="kt">WrapUpStrategy</span>
<span class="w">     </span><span class="kr">else</span><span class="w"> </span><span class="kt">NormalStrategy</span>
</code></pre></div>

<p>这展示了 <strong>Dynamic Planning</strong>：根据元数据（Budget）动态改变计算图结构。</p>
</details>
<p><strong>练习 6.7：Jitter 算法对比</strong>
请对比 "Equal Jitter" 和 "Full Jitter" 的区别。</p>
<ul>
<li>Equal Jitter: <code>temp = min(cap, base * 2^n); sleep = temp/2 + random(0, temp/2)</code></li>
<li>Full Jitter: <code>temp = min(cap, base * 2^n); sleep = random(0, temp)</code>
在竞争非常激烈的场景下（例如 1000 个 Agent 抢 1 个 API），哪种更好？为什么？</li>
</ul>
<details>
<summary>点击查看提示</summary>
<p>思考平均等待时间和分布的离散程度。</p>
</details>
<details>
<summary>参考答案</summary>
<p><strong>Full Jitter 更好</strong>。</p>
<ul>
<li>Equal Jitter 保证了至少等待 <code>temp/2</code> 的时间，这虽然避免了立即重试，但让所有请求都挤在 <code>[temp/2, temp]</code> 这个较窄的区间内。</li>
<li>Full Jitter 的范围是 <code>[0, temp]</code>，分布更加均匀（Uniform Distribution），能最大限度地利用时间窗口分散请求压力。虽然有极小概率随机到 0，但整体吞吐量通常更高。</li>
</ul>
</details>
<hr />
<h2 id="5-gotchas">5. 常见陷阱与错误 (Gotchas)</h2>
<h3 id="51-zombie-requests">5.1 幽灵请求 (Zombie Requests)</h3>
<ul>
<li><strong>现象</strong>：Agent 已经因为超时向用户报错了，但后台服务器还在傻傻地跑那个耗时 2 分钟的推理任务，消耗昂贵的 GPU。</li>
<li><strong>原因</strong>：实现了 <code>timeout</code> 逻辑，但没有实现<strong>Cancellation（取消）</strong>逻辑。只是客户端不再等待结果，但服务端没有收到“停止”信号。</li>
<li><strong>修复</strong>：确保你的 IO Runtime 支持 <code>bracket</code> 或 <code>resource</code> 模式，并且底层 HTTP 客户端能传播 <code>Context.Cancel</code> 信号断开 TCP 连接。</li>
</ul>
<h3 id="52-jitter">5.2 错误的 Jitter 实现</h3>
<ul>
<li><strong>错误代码</strong><code>sleep(base * 2^n + random(0, 100ms))</code></li>
<li><strong>问题</strong>：这里的随机量（100ms）相对于指数增长的基数（例如 10秒、20秒）太小了，几乎起不到分散流量的作用。</li>
<li><strong>修复</strong>：随机性必须与当前的退避时间<strong>成比例</strong>（Proportional），而不是一个固定常数。</li>
</ul>
<h3 id="53-budget-leak">5.3 预算泄露 (Budget Leak)</h3>
<ul>
<li><strong>现象</strong>：设置了 <code>max_tokens=4000</code>，结果跑出了 8000 tokens 的账单。</li>
<li>
<p><strong>原因</strong>：
1. 只计算了 Response，忘了计算 Prompt（Prompt 往往比 Output 长得多）。
2. Agent 进行了多次“内部思考”或“工具尝试”，这些中间步骤虽然没有展示给用户，但都实打实消耗了 Token。</p>
</li>
<li>
<p><strong>Rule of Thumb</strong>：Budget Wrapper 必须包裹在<strong>最底层</strong>的 LLM 请求函数上，而不是包裹在 Agent 的顶层逻辑上，确保统计无死角。</p>
</li>
</ul>
<h3 id="54">5.4 熔断器“永不开闸”</h3>
<ul>
<li><strong>现象</strong>：服务恢复了，但 Agent 还是拒绝所有请求。</li>
<li><strong>原因</strong>：熔断器进入 <code>Half-Open</code> 状态后，放行的那个“探针请求”如果因为偶发原因（如超时）失败了，熔断器会再次 <code>Open</code> 并重置冷却时间。如果网络不稳定，可能导致系统长期卡在“断开”状态。</li>
<li><strong>修复</strong>：在 Half-Open 状态下，可以考虑允许稍微多一点的探针（如 2-3 个），或者对探针请求使用更宽容的超时策略。</li>
</ul>
<h3 id="55">5.5 重试了不该重试的错误</h3>
<ul>
<li><strong>现象</strong>：Prompt 里面写错了变量名，导致 LLM API 返回 <code>400 Bad Request</code>。Agent 坚持重试了 5 次。</li>
<li><strong>后果</strong>：浪费时间，给开发者造成困扰。</li>
<li><strong>修复</strong>：建立严格的 <strong>Error Predicate（错误断言）</strong>。只有被标记为 <code>Retryable</code> 的错误（网络、5xx）才走重试流程。<code>4xx</code> 错误通常意味着代码 bug，应该立即 Fail。</li>
</ul>
            </article>
            
            <nav class="page-nav"><a href="chapter5.html" class="nav-link prev">← Chapter 5 — Runtime 与调度：从解释器到并发、取消与资源管理 (chapter5.md)</a><a href="chapter7.html" class="nav-link next">Chapter 7 — Coding Agent 的 Loop Detection：让 Agent 可终止、可解释 →</a></nav>
        </main>
    </div>
</body>
</html>