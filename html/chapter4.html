<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="./">
    <title>Chapter 4 — Agent DSL：把工具、记忆与控制流做成“可解释的 effect”</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/highlight.css">
    <script src="assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebar-search-input" placeholder="搜索..." autocomplete="off">
            </div>
            <div id="tree-container">
                <ul class="nav-list"><li class=""><a href="index.html">《用 IO Monad 搭建 LLM Agent：从 Kleisli 到事件建模与 FRP》目录（index.md）</a></li><li class=""><a href="chapter1.html">Chapter 1 — LLM Agent 的“抽象边界”：为什么从 IO Monad 出发</a></li><li class=""><a href="chapter2.html">Chapter 2 — IO Monad 速成：从概念到工程实现</a></li><li class=""><a href="chapter3.html">Chapter 3 — Kleisli Arrow：把“带 IO 的函数”当作可组合箭头</a></li><li class="active"><a href="chapter4.html">Chapter 4 — Agent DSL：把工具、记忆与控制流做成“可解释的 effect”</a></li><li class=""><a href="CLAUDE.html">Untitled</a></li></ul>
            </div>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="chapter-4-agent-dsl-effect">Chapter 4 — Agent DSL：把工具、记忆与控制流做成“可解释的 effect”</h1>
<h2 id="1">1. 开篇段落：从“写脚本”到“写剧本”</h2>
<p>在传统的 Python 脚本式开发中，我们习惯于直接调用 <code>openai.ChatCompletion.create</code> 或 <code>pinecone.upsert</code>。这种做法在 Demo 阶段效率极高，但在生产环境和复杂 Agent 系统中，它会导致代码变成一团难以维护的“意大利面条”：</p>
<ul>
<li><strong>不可测试</strong>：单元测试需要 mock 几十个不同的库函数。</li>
<li><strong>不可复现</strong>：LLM 的随机性、网络抖动、时间戳的变化，使得 Bug 难以重现。</li>
<li><strong>不可观测</strong>：业务逻辑与副作用（IO）紧密耦合，很难看清 Agent 到底“想”做什么，只能看到它“做”了什么。</li>
</ul>
<p>本章的核心思想：<strong>将 Agent 的业务逻辑（剧本）与执行逻辑（演出）彻底分离</strong>。</p>
<p>我们将定义一套 <strong>Domain Specific Language (DSL)</strong> —— 或者称为“代数（Algebra）” —— 来描述 Agent 的所有能力。Agent 不再直接“打电话给 OpenAI”，而是生成一个“我想打电话”的指令。这个指令由 <strong>解释器（Interpreter）</strong> 接收并执行。这种<strong>依赖倒置</strong>将赋予我们控制时间的上帝视角：我们可以让时间倒流、让 API 必定失败、或者让 Agent 在沙盒中空转。</p>
<p><strong>本章学习目标</strong>：</p>
<ol>
<li><strong>能力建模</strong>：如何将 LLM、工具、记忆、时钟、随机数抽象为标准的 Effect。</li>
<li><strong>实现范式</strong>：深入对比 <strong>Final Tagless</strong>（基于接口）与 <strong>Free Monad</strong>（基于数据结构）的工程权衡。</li>
<li><strong>解释器模式</strong>：构建生产（Prod）、测试（Test）、录制回放（VCR）、以及“人类介入（Human-in-the-loop）”解释器。</li>
<li><strong>纯洁性原则</strong>：识别并隔离代码中的式副作用。</li>
</ol>
<hr />
<h2 id="2">2. 文字论述</h2>
<h3 id="21">2.1 架构总览：洋葱模型</h3>
<p>在引入 DSL 后，Agent 的架构将呈现出清晰的分层结构。</p>
<div class="codehilite"><pre><span></span><code><span class="nb">+-------------------------------------------------------+</span>
<span class="c">|  Layer 1: Business Logic (The Script)                 |</span>
<span class="c">|  </span><span class="nb">-</span><span class="c"> &quot;Pure&quot; code                                        |</span>
<span class="c">|  </span><span class="nb">-</span><span class="c"> Describes WHAT to do using DSL interfaces          |</span>
<span class="c">|  </span><span class="nb">-</span><span class="c"> No dependencies on OpenAI/LangChain/AWS SDKs       |</span>
<span class="nb">+-------------------------------------------------------+</span>
<span class="c">           |                   |                   |</span>
<span class="c">    (uses Chat Algebra) (uses Mem Algebra)  (uses Tool Algebra)</span>
<span class="c">           |                   |                   |</span>
<span class="nb">+-------------------------------------------------------+</span>
<span class="c">|  Layer 2: The DSL Definition (The Vocabulary)         |</span>
<span class="c">|  </span><span class="nb">-</span><span class="c"> Interfaces / Typeclasses / Data Structures         |</span>
<span class="c">|  </span><span class="nb">-</span><span class="c"> Defines types: ChatReq</span><span class="nt">,</span><span class="c"> ChatResp</span><span class="nt">,</span><span class="c"> KVGet</span><span class="nt">,</span><span class="c"> KVPut     |</span>
<span class="nb">+-------------------------------------------------------+</span>
<span class="c">           |                   |                   |</span>
<span class="c">    (interpreted by)    (interpreted by)    (interpreted by)</span>
<span class="c">           |                   |                   |</span>
<span class="nb">+-------------------------------------------------------+</span>
<span class="c">|  Layer 3: Interpreters (The Actors)                   |</span>
<span class="c">|  </span><span class="k">[</span><span class="c">Prod Interpreter</span><span class="k">]</span><span class="c">  </span><span class="k">[</span><span class="c">Test Interpreter</span><span class="k">]</span><span class="c">  </span><span class="k">[</span><span class="c">Replay Int</span><span class="k">]</span><span class="c"> |</span>
<span class="c">|  </span><span class="nb">-</span><span class="c"> Calls OpenAI      </span><span class="nb">-</span><span class="c"> Returns Strings   </span><span class="nb">-</span><span class="c"> Reads File |</span>
<span class="c">|  </span><span class="nb">-</span><span class="c"> Connects Redis    </span><span class="nb">-</span><span class="c"> Uses HashMap      </span><span class="nb">-</span><span class="c"> Deterministic|</span>
<span class="nb">+-------------------------------------------------------+</span>
</code></pre></div>

<h3 id="22-defining-the-algebras">2.2 核心代数定义 (Defining the Algebras)</h3>
<p>我们需要将 Agent 交互世界的触角一一斩断，用抽象接口接管。以下是标准的 Agent 能力集：</p>
<h4 id="221-llm-chat">2.2.1 认知代数：<code>LLM</code> / <code>Chat</code></h4>
<p>这是最复杂的 Effect。不要仅仅传递 String，要传递语义结构。</p>
<ul>
<li><strong>操作定义</strong>：</li>
<li><code>chat(messages: List[Message], config: Config) -&gt; m Response</code></li>
<li>
<p><code>stream(messages: List[Message]) -&gt; m (Stream Response)</code> (流式)</p>
</li>
<li>
<p><strong>关键抽象</strong>：</p>
</li>
<li><strong>Model Agnostic</strong>：输入输出结构应屏蔽 <code>gpt-4</code> 和 <code>claude-3</code> 差异（例如，统一将 <code>function_call</code> 和 <code>tool_use</code> 映射为标准的 <code>ToolInvocation</code> 对象）。</li>
<li><strong>Cost Awareness</strong>：返回值应包含 <code>Usage(prompt_tokens, completion_tokens)</code>，以便中间件计算成本。</li>
</ul>
<h4 id="222-tools">2.2.2 行为代数：<code>Tools</code></h4>
<p>Agent 通过工具改变世界。</p>
<ul>
<li><strong>操作定义</strong>：</li>
<li><code>call(tool_name: String, args: Json) -&gt; m Json</code></li>
<li>
<p><code>list_tools() -&gt; m List[ToolSchema]</code></p>
</li>
<li>
<p><strong>为什么需要 list?</strong>：Agent 有时需要根据上下文动态“看到”有哪些工具可用（例如，根据用户权限过滤工具）。</p>
</li>
</ul>
<h4 id="223-memory">2.2.3 状态代数：<code>Memory</code></h4>
<p>分为短期（会话）和长期（知识库）。</p>
<ul>
<li><strong>KV Store (Short-term)</strong>: <code>get(key)</code>, <code>put(key, value, ttl)</code></li>
<li><strong>Vector Store (Long-term)</strong>: <code>search(vector, top_k, threshold) -&gt; m List[Doc]</code></li>
<li><strong>注意</strong>：<code>Embedding</code> 计算通常也是一个独立的 Effect（<code>Embed : String -&gt; m Vector</code>），因为它涉及 API 调用和费用。</li>
</ul>
<h4 id="224-system">2.2.4 环境代数：<code>System</code> (隐形的关键)</h4>
<p>这是大多数工程师略的地方。为了实现 100% 的可复现性（Replayability），<strong>所有的非确定性来源必须被托管</strong>。</p>
<ul>
<li><strong>Clock</strong>: <code>now() -&gt; m Timestamp</code>。</li>
<li>
<p><em>用途</em>：在测试中，你可以冻结时间，或者让时间快进，测试 <code>TTL</code> 过期逻辑。</p>
</li>
<li>
<p><strong>Random</strong>: <code>uuid() -&gt; m String</code>, <code>nextInt(min, max) -&gt; m Int</code>, <code>shuffle(list) -&gt; m List</code>。</p>
</li>
<li><em>用途</em>：Agent 的“探索/利用”策略、ID 生成、重试抖动（Jitter）都需要随机数。如果直接调 <code>Math.random()</code>，你就无法回放一次特定的失败。</li>
</ul>
<h4 id="225-telemetry">2.2.5 观测代数：<code>Telemetry</code></h4>
<p>日志和追踪不应是代码里的 <code>print</code> 语句，而是结构化的 Effect。</p>
<ul>
<li><strong>Trace</strong>: <code>span(name, attributes) { inner_logic } -&gt; m Result</code></li>
<li><strong>Metric</strong>: <code>counter(name, value)</code>, <code>gauge(name, value)</code></li>
</ul>
<h3 id="23-free-monad-vs-final-tagless">2.3 两种流派：Free Monad vs. Final Tagless</h3>
<p>如何实现上述 DSL？工程界主要有两种选择。</p>
<p>| 特性 | Free Monad (Reified AST) | Final Tagless (Abstract Interface) |</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Free Monad (Reified AST)</th>
<th>Final Tagless (Abstract Interface)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>核心隐</strong></td>
<td><strong>购物清单</strong>。你把要买的东西写在纸上（构建数据结构），然后交给跑腿的人去买（解释器）。</td>
<td><strong>依赖注入</strong>。你告诉函数你需要“会买东西的人”（接口约束），编译器注入具体的实现对象。</td>
</tr>
<tr>
<td><strong>代码表现</strong></td>
<td>递归的数据类型（Tree）。程序是一个值。</td>
<td>带泛型约束的函数：<code>def run[F[_]: Chat: Tool](...)</code></td>
</tr>
<tr>
<td><strong>自省能力</strong></td>
<td><strong>极强</strong>。你可以在运行前遍历整棵树，统计将会调用几次 API，或者优化执行顺序。</td>
<td><strong>弱</strong>。代码编译成了函数调用，运行时很难“预知”后续步骤。</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>较慢。每一步都需要构建对象和遍历。</td>
<td>极快。通常内联为直接的方法调用。</td>
</tr>
<tr>
<td><strong>适用语言</strong></td>
<td>Haskell, Scala (Cats/Zio), TypeScript (fp-ts)</td>
<td>Scala, Java, C#, TypeScript (Interface)</td>
</tr>
<tr>
<td><strong>推荐场景</strong></td>
<td>需要对程序进行深度静态分析、优化或序列化传输时。</td>
<td><strong>绝大多数生产环境 Agent</strong>。简单、高效、易懂。</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>Rule of Thumb</strong>：除非你在写一个需要“序列化 Agent 执行计划并发给另一台机器运行”的分布式系统，否则优先选择 <strong>Final Tagless (Interface pattern)</strong>。它更符合主流工程直觉。</p>
</blockquote>
<h3 id="24-the-power-of-interpreters">2.4 解释器的魔力 (The Power of Interpreters)</h3>
<p>一旦我们付出了“定义 DSL”的代价，我们将收获巨大的灵活性。我们可以编写多种解释器来应对不同场景：</p>
<ol>
<li>
<p><strong>Production Interpreter</strong>：
* 连接真实的 <code>OpenAI</code> API。
* 连接真实的 <code>Redis</code> / <code>Pinecone</code>。
* 使用系统时钟。</p>
</li>
<li>
<p><strong>Mock Interpreter (Unit Test)</strong>：
* <code>Chat</code>: 永远返回 "Hello World" 或根据 Prompt 关键词匹配返回。
* <code>Memory</code>: 使用内存 <code>Map</code> 模拟数据库。
* <code>Clock</code>: 时间永远停在 <code>2024-01-01</code>。
* <strong>价值</strong>：毫秒级运行整个对话流程测试，零成本。</p>
</li>
<li>
<p><strong>Record/Replay Interpreter (Integration Test / Debug)</strong>：
* <strong>Record 模式</strong>：作为 Production 的代理。运行时，计算 <code>Hash(Input)</code>，将 <code>(Input, Output)</code> 序列化存入 JSON 文件（Tape）。
* <strong>Replay 模式</strong>：通过计算 <code>Hash(Input)</code> 从 JSON 文件中查找 Response。如果找不到，报错。
* <strong>价值</strong>：捕获一次线上出现的复杂 Bug（例如 10 轮对话后的逻辑错误），将其固化为测试用例，在本地反复调试直到修复。</p>
</li>
<li>
<p><strong>Human-in-the-Loop Interpreter</strong>：
* 对于 <code>Tool.call("delete_database")</code> 这样的高危操作，解释器可以拦截执行，通过 Slack/Email 发送审批请求，等待人类批准后再恢复执行（或抛出拒绝）。
* <strong>注意</strong>：在业务逻辑代码中，这看起来只是普通的 <code>tool.call</code>，审批流程完全被解释器封装了。</p>
</li>
</ol>
<hr />
<h2 id="3">3. 本章小结</h2>
<ul>
<li><strong>DSL 是契约</strong>：Agent 代码描述意图，Interpreter 负责落实。</li>
<li><strong>全量抽象</strong>：不仅仅是 LLM，凡是涉及 IO、状态、时间、随机性的操作，都必须进入 DSL。</li>
<li><strong>Final Tagless</strong>：是实现 DSL 的一种轻量级、高性能的工程模式，本质上是“高阶依赖入”。</li>
<li><strong>可测性红利</strong>：通过更换解释器，我们可以把“不可测”的 AI 应用变成“完全确定性”的软件系统。</li>
<li><strong>回放机制</strong>：Record/Replay 解释器是调试复杂 Agent 行为（幻觉、死循环）的终极武器。</li>
</ul>
<hr />
<h2 id="4">4. 练习题</h2>
<h3 id="_1">基础题</h3>
<p><strong>Q1. 定义 Time Algebra</strong>
在许多 Agent 任务中，Agent 需要知道“今天是星期几”来决定是否发送工作邮件。
请定义一个简单的 <code>Clock</code> 能力接口（可以用伪代码或 TypeScript 接口），并给出其 Production 实现和 Test 实现。</p>
<details>
<summary>点击展开答案</summary>
<p><strong>Hints</strong>:
Production 使用 <code>Date.now()</code>，Test 使用一个可变的变量。</p>
<p><strong>Answer (TypeScript 风格)</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="c1">// 1. Algebra (Interface)</span>
<span class="kd">interface</span><span class="w"> </span><span class="nx">Clock</span><span class="o">&lt;</span><span class="nx">F</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">now</span><span class="p">()</span><span class="o">:</span><span class="w"> </span><span class="nx">F</span><span class="o">&lt;</span><span class="nb">Date</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 2. Production Implementation (IO based)</span>
<span class="kd">const</span><span class="w"> </span><span class="nx">prodClock</span><span class="o">:</span><span class="w"> </span><span class="kt">Clock</span><span class="o">&lt;</span><span class="nx">IO</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">now</span><span class="o">:</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">IO</span><span class="p">(()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Date</span><span class="p">())</span>
<span class="p">};</span>

<span class="c1">// 3. Test Implementation (State based)</span>
<span class="kd">class</span><span class="w"> </span><span class="nx">MockClock</span><span class="w"> </span><span class="k">implements</span><span class="w"> </span><span class="nx">Clock</span><span class="o">&lt;</span><span class="nx">Identity</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">private</span><span class="w"> </span><span class="nx">_currentTime</span><span class="o">:</span><span class="w"> </span><span class="kt">Date</span><span class="p">;</span>

<span class="w">  </span><span class="kr">constructor</span><span class="p">(</span><span class="nx">start</span><span class="o">:</span><span class="w"> </span><span class="kt">Date</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">_currentTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">start</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">  </span><span class="c1">// 允许测试代码推进时间</span>
<span class="w">  </span><span class="nx">advance</span><span class="p">(</span><span class="nx">ms</span><span class="o">:</span><span class="w"> </span><span class="kt">number</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="nx">_currentTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Date</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">_currentTime</span><span class="p">.</span><span class="nx">getTime</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">ms</span><span class="p">);</span><span class="w"> </span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="nx">now</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="nx">_currentTime</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

</details>
<p><strong>Q2. 识别隐式依赖</strong>
审查以下代码，找出所有破坏“纯洁性”且需要被抽象进 DSL 的点：</p>
<div class="codehilite"><pre><span></span><code><span class="k">def</span> <span class="nf">decide_action</span><span class="p">(</span><span class="n">user_input</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;User said: </span><span class="si">{</span><span class="n">user_input</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>           <span class="c1"># 1</span>
    <span class="k">if</span> <span class="s2">&quot;urgent&quot;</span> <span class="ow">in</span> <span class="n">user_input</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;call_human&quot;</span>

    <span class="kn">import</span> <span class="nn">uuid</span>
    <span class="n">request_id</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())</span>              <span class="c1"># 2</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># assume db is a global object</span>
        <span class="n">last_seen</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">user_input</span><span class="o">.</span><span class="n">user_id</span><span class="p">)</span>  <span class="c1"># 3</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;error&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;process&quot;</span>
</code></pre></div>

<details>
<summary>点击展开答案</summary>
<p><strong>Answer</strong>:</p>
<ol>
<li><code>print(...)</code>: 标准输出副作用。应抽象为 <code>Logger.info(...)</code>。</li>
<li><code>uuid.uuid4()</code>: 随机性来源。不可复现。应抽象为 <code>UUIDGen.generate()</code>。</li>
<li><code>db.get(...)</code>: 外部 IO 且依赖全局变量。应抽象为 <code>KVStore.get(...)</code>。</li>
</ol>
</details>
<p><strong>Q3. 解释器路由</strong>
假设你的 Agent 需要同时使用 GPT-4 处理复杂逻辑，使用 Haiku 处理简单总结。你应该如何在 DSL 中表达这种需求？</p>
<details>
<summary>点击展开答案</summary>
<p><strong>Answer</strong>:
不要在 DSL 中硬编码模型名。
<strong>方法 A (多代数)</strong>：定义两个能力 <code>SmartChat</code> 和 <code>FastChat</code>。
<strong>方法 B (参数化)</strong>：在 <code>chat</code> 方法中接受一个抽象的 <code>ModelTier</code> 枚举（High/Low/Economy），由解释器决定 <code>High</code> 映射到 GPT-4，<code>Low</code> 映射到 Haiku。推荐方法 B，因为更易于配置切换。</p>
</details>
<h3 id="_2">挑战题</h3>
<p><strong>Q4. 设计“录制/回放”的数据结构</strong>
设计一个 JSON 结构（Tape），用于存储一次 Agent 执行的所有 Effect。
考虑：如果 Agent 并发执行了两个 HTTP 请求，如何确保回放时匹配到正确的响应？</p>
<details>
<summary>点击展开答案</summary>
<p><strong>Hints</strong>:
仅靠顺序匹配在并发场景下是不可靠的。需要指纹（Fingerprint/Hash）。</p>
<p><strong>Answer Sketch</strong>:</p>
<div class="codehilite"><pre><span></span><code><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;trace_id&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;abc-123&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;interactions&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;effect_type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Chat&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;input_hash&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;sha256(messages + config)&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;input_raw&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="err">...</span><span class="w"> </span><span class="p">},</span><span class="w"> </span>
<span class="w">      </span><span class="nt">&quot;output&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="nt">&quot;text&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Hello&quot;</span><span class="p">,</span><span class="w"> </span><span class="nt">&quot;usage&quot;</span><span class="p">:</span><span class="w"> </span><span class="err">...</span><span class="w"> </span><span class="p">},</span>
<span class="w">      </span><span class="nt">&quot;timestamp&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1715000000</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;effect_type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;Tool&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;tool_name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;search&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;args_hash&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;sha256(query=&#39;test&#39;)&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;output&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;...&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;error&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">null</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">  </span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div>

<p><em>并发匹配策略</em>：
在回放时，通常不依赖顺序，而是构建一个 <code>Map&lt;Hash, Queue&lt;Output&gt;&gt;</code>。
当 DSL 请求发生时，计算请求的 Hash，从对应的队列中 <code>pop</code> 出一个预录制的响应。</p>
</details>
<p><strong>Q5. 纯函数式“重试”中间件</strong>
在不修改 <code>Chat</code> 接口定义，也不修改 <code>OpenAIInterpreter</code> 代码的前提下，如何利用 DSL 的组合性，为 <code>Chat</code> 能力增加“失败自动重试 3 次”的功能？</p>
<details>
<summary>点击展开答案</summary>
<p><strong>Answer</strong>:
使用<strong>装饰器模式（Decorator）或高阶解释器</strong>。
编写一个新的解释器 <code>RetryingChatInterpreter</code>，它接收一个基础的 <code>ChatInterpreter</code>。</p>
<div class="codehilite"><pre><span></span><code><span class="kd">const</span><span class="w"> </span><span class="nx">retryingChat</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="nx">base</span><span class="o">:</span><span class="w"> </span><span class="kt">Chat</span><span class="p">,</span><span class="w"> </span><span class="nx">policy</span><span class="o">:</span><span class="w"> </span><span class="kt">RetryPolicy</span><span class="p">)</span><span class="o">:</span><span class="w"> </span><span class="nx">Chat</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">({</span>
<span class="w">  </span><span class="nx">chat</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="nx">req</span><span class="p">)</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// 伪代码：利用 Monad 的递归或 retry 组合子</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nx">retry</span><span class="p">(</span><span class="nx">policy</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">base</span><span class="p">.</span><span class="nx">chat</span><span class="p">(</span><span class="nx">req</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">})</span>
</code></pre></div>

<p>这证明了 Effect 抽象的强大之处：横切关注点（如重试、限流、缓存）可以作为独立的层叠加在核心逻辑之上。</p>
</details>
<hr />
<h2 id="5-gotchas">5. 常见陷阱与错误 (Gotchas)</h2>
<h3 id="51-leaky-abstractions">5.1 抽象泄漏 (Leaky Abstractions)</h3>
<ul>
<li><strong>现象</strong>：你的 DSL 接口中出现了 <code>import { ChatCompletionChunk } from 'openai'</code>。</li>
<li><strong>问题</strong>：这使得 DSL 绑定到了特定的 SDK。如果 OpenAI 更新了 SDK 版本或者你想换 SDK，接口就得变。</li>
<li><strong>对策</strong>：定义自己的 DTO (Data Transfer Objects)。虽然写转换代码很繁琐，但为了架构的整洁是值得的。</li>
</ul>
<h3 id="52">5.2 只有副作用，没有返回值</h3>
<ul>
<li><strong>现象</strong>：<code>log(msg: String) -&gt; m Unit</code>。</li>
<li><strong>问题</strong>：看起来没问题，但在并发场景下，你可能需要等待日志写入完成再终止程序，或者需要捕获日志系统的磁盘满错误。</li>
<li><strong>对策</strong>：即使是 <code>Unit</code> 返回值，也要确保它是包裹在 <code>m</code> (Effect) 中的，并且要考虑是否需要返回一个 <code>Handle</code> 或 <code>Result</code>。</li>
</ul>
<h3 id="53">5.3 混淆“配置”与“上下文”</h3>
<ul>
<li><strong>现象</strong>：把 <code>UserID</code> 或 <code>SessionID</code> 作为 <code>Chat</code> 解释器的初始化参数，而不是每次调用的参数。</li>
<li><strong>问题</strong>：这意味着你的解释器是有状态的（Stateful），难以在多用户并发环境下复用同一个解释器实例。</li>
<li><strong>对策</strong>：解释器应该是无状态的单例。<code>UserID</code> 应该通过 <code>Reader</code> Monad 传递，或者作为 DSL 方法的一个显式参数（Context Object）。</li>
</ul>
<h3 id="54-effect">5.4 所有的东西都是 Effect？</h3>
<ul>
<li><strong>现象</strong>：把 <code>JSON.parse</code> 或 <code>String.split</code> 也做成 Effect。</li>
<li><strong>问题</strong>：过度工程。</li>
<li><strong>Rule of Thumb</strong>：
1. <strong>纯计算</strong>（相同的输入永远得到相同的输出，且无副作用） -&gt; <strong>不需要 Effect</strong>，直接写函数。
2. <strong>不确定性/副作用</strong> -&gt; <strong>必须是 Effect</strong>。</li>
</ul>
            </article>
            
            <nav class="page-nav"><a href="chapter3.html" class="nav-link prev">← Chapter 3 — Kleisli Arrow：把“带 IO 的函数”当作可组合箭头</a><a href="CLAUDE.html" class="nav-link next">Untitled →</a></nav>
        </main>
    </div>
</body>
</html>